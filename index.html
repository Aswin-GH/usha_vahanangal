<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Flipbook</title>
  <style>
    :root{
      --page-radius: 18px;
      --page-shadow: 0 18px 45px rgba(0,0,0,0.28);
      --inner-shadow: inset 0 0 0 1px rgba(255,255,255,0.10);
      --paper: #f4f1ea;
      --bg: #111;
      --spread-ar: 2970 / 2056; /* full slide aspect ratio */
      --ui-reserve: 140px; /* space for stage padding + HUD + safe areas */
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 700px at 50% 40%, #1a1a1a, var(--bg));
      overflow: hidden;
      touch-action: none; /* we handle gestures */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    .stage{
      height: 100%;
      display: grid;
      place-items: center;
      padding: 22px;
      box-sizing: border-box;
    }

    .bookViewport{
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      overflow: hidden;
      touch-action: none; /* we implement pinch/zoom/pan */
    }

    /* Outer book frame */
    .book{
      /* Fit by BOTH width and height: width <= availableHeight * aspectRatio */
      width: min(92vw, 1200px, calc((100vh - var(--ui-reserve) - env(safe-area-inset-top) - env(safe-area-inset-bottom)) * (var(--spread-ar))));
      max-height: calc(100vh - var(--ui-reserve) - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      aspect-ratio: var(--spread-ar); /* match 2970x2056 to avoid stretch */
      position: relative;
      perspective: 1600px;
      user-select: none;
      transform-origin: 50% 50%;
      will-change: transform;
    }

    /* Spread is the visible surface area */
    .spread{
      position:absolute; inset:0;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0;
    }

    .slot{
      position: relative;
      overflow: visible;
    }

    /* A static page */
    .page{
      position:absolute; inset:0;
      border-radius: var(--page-radius);
      box-shadow: var(--page-shadow), var(--inner-shadow);
      background: var(--paper);
      overflow: hidden;
      transform: translateZ(0); /* keep crisp */
    }

    .page, .pageFace, .leaf, .leafFace{
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Image-cropped page face */
    .pageFace{
      position:absolute; inset:0;
      border-radius: var(--page-radius);
      background-repeat: no-repeat;
      background-size: 200% 100%;   /* double spread */
      background-position: 0% 0%;
      background-color: var(--paper);
      filter: saturate(1.02) contrast(1.02);
    }

    /* Optional overlay for subtle paper shading */
    .pageTint{
      position:absolute; inset:0;
      border-radius: var(--page-radius);
      background: linear-gradient(90deg, rgba(0,0,0,0.06), rgba(0,0,0,0.00) 28%, rgba(0,0,0,0.03));
      pointer-events:none;
      mix-blend-mode: multiply;
      opacity: 0.6;
    }

    /* Flipping leaf */
    .leaf{
      position:absolute;
      top:0; bottom:0;
      width: 50%;
      transform-style: preserve-3d;
      z-index: 150;
      pointer-events: none; /* we track gesture on book */
    }

    /* For the front/back faces of the flipping leaf */
    .leafFace{
      position:absolute; inset:0;
      border-radius: var(--page-radius);
      overflow:hidden;
      backface-visibility: hidden;
      box-shadow: var(--page-shadow), var(--inner-shadow);
      background: var(--paper);
    }

    .leafFace .pageFace{ border-radius: var(--page-radius); }

    /* Back face flips */
    .leafBack{
      transform: rotateY(180deg);
    }


    /* Dynamic shadows during flip */
    .shade{
      position:absolute; inset:0;
      border-radius: var(--page-radius);
      pointer-events:none;
      opacity: 0;
      transition: opacity 80ms linear;
    }

    /* forward (right->left) */
    .shade.forward{
      background: linear-gradient(270deg, rgba(0,0,0,0.40), rgba(0,0,0,0.05) 55%, rgba(0,0,0,0.00));
    }

    /* backward (left->right) */
    .shade.backward{
      background: linear-gradient(90deg, rgba(0,0,0,0.40), rgba(0,0,0,0.05) 55%, rgba(0,0,0,0.00));
    }

    /* Spine hint */
    .spine{
      position:absolute;
      left:50%; top:3%; bottom:3%;
      width: 10px;
      transform: translateX(-50%);
      border-radius: 10px;
      background: linear-gradient(90deg, rgba(0,0,0,0.35), rgba(255,255,255,0.10), rgba(0,0,0,0.35));
      opacity: 0.35;
      pointer-events:none;
      filter: blur(0.2px);
    }

    /* Empty side background */
    .empty{
      position:absolute; inset:0;
      border-radius: var(--page-radius);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
      opacity: 0.35;
    }

    /* Shadow handoff bridge to avoid end-of-flip jump */
    .handoff{
      position: absolute;
      top: 0; bottom: 0;
      width: 50%;
      pointer-events: none;
      z-index: 120; /* above static pages, below turning leaf */
      opacity: 0;
      transition: opacity 140ms linear;
      border-radius: var(--page-radius);
      overflow: hidden;
    }

    .handoff.forward{
      left: 50%;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      background:
        linear-gradient(270deg, rgba(0,0,0,0.22), rgba(0,0,0,0.10) 35%, rgba(0,0,0,0.00) 72%),
        radial-gradient(120% 90% at 10% 50%, rgba(0,0,0,0.12), rgba(0,0,0,0.00) 70%);
    }

    .handoff.backward{
      left: 0%;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      background:
        linear-gradient(90deg, rgba(0,0,0,0.22), rgba(0,0,0,0.10) 35%, rgba(0,0,0,0.00) 72%),
        radial-gradient(120% 90% at 90% 50%, rgba(0,0,0,0.12), rgba(0,0,0,0.00) 70%);
    }

    /* HUD */
    .hud{
      position: fixed;
      left: 50%;
      bottom: calc(18px + env(safe-area-inset-bottom));
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 200;
      pointer-events: none;
      opacity: 0.95;
    }

    .hudPill{
      pointer-events: auto;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      color: rgba(255,255,255,0.92);
      font-size: 13px;
      letter-spacing: 0.2px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
    }

    .hudHint{
      color: rgba(255,255,255,0.70);
      font-size: 12px;
      letter-spacing: 0.2px;
      user-select: none;
    }

    /* Jump overlay */
    .jumpOverlay{
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0,0,0,0.55);
      z-index: 300;
      padding: 18px;
      box-sizing: border-box;
    }

    .jumpOverlay.open{ display: grid; }

    .jumpModal{
      width: min(92vw, 360px);
      border-radius: 16px;
      background: rgba(20,20,20,0.92);
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.08);
      padding: 16px;
      box-sizing: border-box;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .jumpTitle{
      color: rgba(255,255,255,0.92);
      font-size: 14px;
      margin-bottom: 10px;
      letter-spacing: 0.2px;
    }

    .jumpInput{
      width: 100%;
      border-radius: 12px;
      padding: 12px 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.92);
      outline: none;
      font-size: 14px;
      box-sizing: border-box;
    }

    .jumpRow{
      display: flex;
      gap: 10px;
      margin-top: 12px;
    }

    .jumpBtn{
      flex: 1;
      border: 0;
      border-radius: 12px;
      padding: 11px 10px;
      background: rgba(255,255,255,0.12);
      color: rgba(255,255,255,0.92);
      cursor: pointer;
      font-size: 13px;
      letter-spacing: 0.2px;
    }

    .jumpBtn.ghost{
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.82);
    }

    .jumpTip{
      margin-top: 10px;
      color: rgba(255,255,255,0.62);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="stage">
    <div class="bookViewport" id="bookViewport">
      <div class="book" id="book">
        <div class="spine" id="spine"></div>
        <div class="spread" id="spread">
          <div class="slot" id="leftSlot"></div>
          <div class="slot" id="rightSlot"></div>
        </div>
      </div>
    </div>

    <div class="hud" id="hud">
      <div class="hudPill" id="pageIndicator">Page 1 / 50</div>
      <div class="hudHint" id="hudHint">← / →, Space, G to jump</div>
    </div>

    <div class="jumpOverlay" id="jumpOverlay" aria-hidden="true">
      <div class="jumpModal" role="dialog" aria-modal="true" aria-label="Jump to page">
        <div class="jumpTitle">Jump to page</div>
        <input class="jumpInput" id="jumpInput" type="number" min="1" max="50" placeholder="1–50" />
        <div class="jumpRow">
          <button class="jumpBtn" id="jumpGo">Go</button>
          <button class="jumpBtn ghost" id="jumpCancel">Cancel</button>
        </div>
        <div class="jumpTip">Tip: Press Enter to go, Esc to close</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---- CONFIG ----
  const TOTAL_SLIDES = 25;
  const TOTAL_PAGES = 50;  // = 2 * TOTAL_SLIDES
  const IMAGES_DIR = "images";

  // ---- PAGE -> SLIDE HALF MAPPING ----
  // returns {slideIndex:1..19, half:"left"|"right"}
  function pageToSlide(page){
    if(page < 1 || page > TOTAL_PAGES) return null;
    if(page === 1)  return { slideIndex: 1, half: "right" };
    if(page === TOTAL_PAGES) return { slideIndex: 1, half: "left"  };
    // pages 2..(TOTAL_PAGES-1) live in slide2..slideN
    const slideIndex = Math.floor((page + 2) / 2); // 2->2, 3->2, 4->3, ...
    const half = (page % 2 === 0) ? "left" : "right";
    return { slideIndex, half };
  }

  function pageStyle(page){
    const map = pageToSlide(page);
    if(!map) return null;
    const url = `${IMAGES_DIR}/Slide${map.slideIndex}.jpeg`;
    const pos = (map.half === "left") ? "0% 0%" : "100% 0%";
    return { url, pos };
  }

  // ---- PRELOAD (slides are the real assets) ----
  const slideCache = new Map(); // slideIndex -> Image
  function slideUrl(slideIndex){
    return `${IMAGES_DIR}/Slide${slideIndex}.jpeg`;
  }

  function preloadSlide(slideIndex){
    if(slideIndex < 1 || slideIndex > TOTAL_SLIDES) return;
    if(slideCache.has(slideIndex)) return;
    const img = new Image();
    img.decoding = "async";
    img.loading = "eager";
    img.src = slideUrl(slideIndex);
    slideCache.set(slideIndex, img);
  }

  function preloadAroundCurrent(){
    // Preload current + next/prev spread slides
    const pagesToConsider = [];
    if(leftPage) pagesToConsider.push(leftPage);
    if(rightPage) pagesToConsider.push(rightPage);
    // Look-ahead/look-behind
    if(rightPage && rightPage + 1 <= TOTAL_PAGES) pagesToConsider.push(rightPage + 1);
    if(rightPage && rightPage + 2 <= TOTAL_PAGES) pagesToConsider.push(rightPage + 2);
    if(leftPage && leftPage - 1 >= 1) pagesToConsider.push(leftPage - 1);
    if(leftPage && leftPage - 2 >= 1) pagesToConsider.push(leftPage - 2);

    const slideSet = new Set();
    for(const p of pagesToConsider){
      const m = pageToSlide(p);
      if(m) slideSet.add(m.slideIndex);
    }
    // Add immediate neighbors for smoother paging
    for(const s of [...slideSet]){
      slideSet.add(s - 1);
      slideSet.add(s + 1);
    }
    for(const s of slideSet){
      preloadSlide(s);
    }
  }

  // ---- AUTO-DETECT SLIDE COUNT (slide1..slideN) ----
  // [auto-detection logic removed for fixed slide count]

  // ---- AUDIO (sine-tone sequences, no external files) ----
  let audioCtx = null;
  function ensureAudio(){
    if(audioCtx) return audioCtx;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if(!Ctx) return null;
    audioCtx = new Ctx();
    return audioCtx;
  }

  function playSineSequence(isForward){
    const ctx = ensureAudio();
    if(!ctx) return;
    if(ctx.state === "suspended") ctx.resume().catch(()=>{});

    const now = ctx.currentTime;
    const master = ctx.createGain();
    master.gain.setValueAtTime(0.0001, now);
    master.gain.exponentialRampToValueAtTime(0.22, now + 0.01);
    master.gain.exponentialRampToValueAtTime(0.0001, now + 0.22);
    master.connect(ctx.destination);

    const freqs = isForward ? [620, 460, 520] : [520, 410, 470];
    let t = now;
    for(let i=0;i<freqs.length;i++){
      const o = ctx.createOscillator();
      o.type = "sine";
      o.frequency.setValueAtTime(freqs[i], t);
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(1.0, t + 0.008);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.07);
      o.connect(g);
      g.connect(master);
      o.start(t);
      o.stop(t + 0.08);
      t += 0.06;
    }
  }

  function setIndicatorText(){
    // Show current spread like "2–3 / 38" or "1 / 38"
    if(!pageIndicator) return;
    if(leftPage && rightPage){
      pageIndicator.textContent = `Pages ${leftPage}–${rightPage} / ${TOTAL_PAGES}`;
    } else if(rightPage){
      pageIndicator.textContent = `Page ${rightPage} / ${TOTAL_PAGES}`;
    } else if(leftPage){
      pageIndicator.textContent = `Page ${leftPage} / ${TOTAL_PAGES}`;
    } else {
      pageIndicator.textContent = `Page 1 / ${TOTAL_PAGES}`;
    }
  }

  // ---- RESISTANCE / SOFTENING ----
  function smootherstep(x){
    // 0..1 with resistance near ends
    x = Math.max(0, Math.min(1, x));
    return x * x * x * (x * (x * 6 - 15) + 10);
  }

  // ---- DOM HELPERS ----
  const book = document.getElementById("book");
  const bookViewport = document.getElementById("bookViewport");
  const spine = document.getElementById("spine");
  const leftSlot  = document.getElementById("leftSlot");
  const rightSlot = document.getElementById("rightSlot");

  // HUD / Jump UI
  const pageIndicator = document.getElementById("pageIndicator");
  const jumpOverlay = document.getElementById("jumpOverlay");
  const jumpInput = document.getElementById("jumpInput");
  const jumpGo = document.getElementById("jumpGo");
  const jumpCancel = document.getElementById("jumpCancel");

  // Shadow handoff bridge element (created on demand)
  let handoffEl = null;
  function ensureHandoff(direction){
    if(handoffEl){
      handoffEl.remove();
      handoffEl = null;
    }
    handoffEl = document.createElement("div");
    handoffEl.className = `handoff ${direction}`;
    book.appendChild(handoffEl);
    return handoffEl;
  }

  function removeHandoffSoon(){
    if(!handoffEl) return;
    const el = handoffEl;
    handoffEl = null;
    el.style.opacity = "0";
    setTimeout(() => { try { el.remove(); } catch(e){} }, 180);
  }

  function clearSlot(slot){
    slot.innerHTML = "";
  }

  function makeEmpty(){
    const e = document.createElement("div");
    e.className = "empty";
    return e;
  }

  function makeStaticPage(pageNumber){
    const p = document.createElement("div");
    p.className = "page";

    const face = document.createElement("div");
    face.className = "pageFace";
    const tint = document.createElement("div");
    tint.className = "pageTint";

    const st = pageStyle(pageNumber);
    if(st){
      face.style.backgroundImage = `url("${st.url}")`;
      face.style.backgroundPosition = st.pos;
    } else {
      face.style.backgroundImage = "none";
    }

    p.appendChild(face);
    p.appendChild(tint);
    return p;
  }

  function makeLeaf(direction, frontPage, backPage){
    // direction: "forward" (right->left) or "backward" (left->right)
    const leaf = document.createElement("div");
    leaf.className = "leaf";
    leaf.dataset.direction = direction;

    // leaf sits on right half for forward, left half for backward
    if(direction === "forward"){
      leaf.style.left = "50%";
      leaf.style.transformOrigin = "0% 50%"; // spine
    } else {
      leaf.style.left = "0%";
      leaf.style.transformOrigin = "100% 50%"; // spine
    }

    const front = document.createElement("div");
    front.className = "leafFace leafFront";
    front.appendChild(makeStaticPage(frontPage).firstChild); // pageFace only
    // add tint similar to static
    const tintF = document.createElement("div");
    tintF.className = "pageTint";
    front.appendChild(tintF);

    const back = document.createElement("div");
    back.className = "leafFace leafBack";
    back.appendChild(makeStaticPage(backPage).firstChild);
    const tintB = document.createElement("div");
    tintB.className = "pageTint";
    back.appendChild(tintB);

    const shade = document.createElement("div");
    shade.className = `shade ${direction === "forward" ? "forward" : "backward"}`;

    leaf.appendChild(front);
    leaf.appendChild(back);
    leaf.appendChild(shade);
    return leaf;
  }

  // ---- BOOK STATE ----
  // visible spread:
  // leftPage is even (2..38) or null
  // rightPage is odd (1..37) or null
  let leftPage = null; // start: empty
  let rightPage = 1;

  // gesture state
  let isDragging = false;
  let dragDir = null; // "forward" or "backward"
  let startX = 0;
  let currentProgress = 0; // 0..1
  let leafEl = null;

  // double-tap / rapid-tap suppression (prevents iOS smart-zoom snapshot glitches)
  let lastTapTime = 0;
  let lastTapX = 0;
  let lastTapY = 0;
  let suppressUntil = 0;

  // general rapid-input suppression (mouse dblclick / touch double-tap)
  let interactionLockUntil = 0;

  // velocity tracking (for commit decisions)
  let lastMoveT = 0;
  let lastRawP = 0;
  let lastVel = 0; // progress per ms, positive means moving toward flip

  // keep an explicit raw progress (before resistance easing)
  let rawProgress = 0;

  // ---- ZOOM / PAN STATE ----
  let zoomScale = 1;
  let panX = 0;
  let panY = 0;
  const ZOOM_MIN = 1;
  const ZOOM_MAX = 3;

  // pointer tracking for pinch
  const activePointers = new Map(); // id -> {x,y}
  let isPinching = false;
  let pinchStartDist = 0;
  let pinchStartScale = 1;
  let pinchStartPanX = 0;
  let pinchStartPanY = 0;
  let pinchStartCenter = {x:0, y:0};

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  function clampPan(){
    if(!bookViewport) return;
    const vw = bookViewport.clientWidth;
    const vh = bookViewport.clientHeight;
    const bw = book.offsetWidth;
    const bh = book.offsetHeight;
    const sw = bw * zoomScale;
    const sh = bh * zoomScale;

    const maxX = Math.max(0, (sw - vw) / 2);
    const maxY = Math.max(0, (sh - vh) / 2);

    panX = clamp(panX, -maxX, maxX);
    panY = clamp(panY, -maxY, maxY);
  }

  function applyViewTransform(){
    clampPan();
    book.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomScale})`;
  }

  function hardResetView(reason){
    // Remove any transient flip artifacts and restore a clean static spread
    try{
      if(leafEl){
        leafEl.remove();
        leafEl = null;
      }
    } catch(e){}

    try{
      if(handoffEl){
        handoffEl.remove();
        handoffEl = null;
      }
    } catch(e){}

    isDragging = false;
    dragDir = null;
    currentProgress = 0;
    rawProgress = 0;

    if(spine){
      spine.style.transition = "";
      spine.style.opacity = "0.35";
    }

    renderSpread();
  }

  function zoomAt(newScale, clientX, clientY){
    if(!bookViewport) return;
    const vp = bookViewport.getBoundingClientRect();
    const cx = vp.left + vp.width/2;
    const cy = vp.top + vp.height/2;
    const px = clientX - cx;
    const py = clientY - cy;

    const prev = zoomScale;
    zoomScale = clamp(newScale, ZOOM_MIN, ZOOM_MAX);

    // keep point under cursor relatively stable by adjusting pan
    const k = (zoomScale / prev);
    panX = panX + px * (1 - k);
    panY = panY + py * (1 - k);

    applyViewTransform();
  }

  // ---- RENDER ----
  function renderSpread(){
    clearSlot(leftSlot);
    clearSlot(rightSlot);

    if(leftPage){
      leftSlot.appendChild(makeStaticPage(leftPage));
    } else {
      leftSlot.appendChild(makeEmpty());
    }

    if(rightPage){
      rightSlot.appendChild(makeStaticPage(rightPage));
    } else {
      rightSlot.appendChild(makeEmpty());
    }

    setIndicatorText();
    // preload soon after each render
    if("requestIdleCallback" in window){
      requestIdleCallback(preloadAroundCurrent, {timeout: 150});
    } else {
      setTimeout(preloadAroundCurrent, 0);
    }
    applyViewTransform();
  }

  function canFlipForward(){
    // forward flip uses rightPage
    return rightPage !== null && rightPage < TOTAL_PAGES;
  }

  function canFlipBackward(){
    // backward flip uses leftPage
    return leftPage !== null;
  }

  function beginFlip(direction){
    // reset ambient shadow for a fresh gesture
    if(spine) spine.style.opacity = "0.35";

    // create a bridge overlay that fades in near the end of the flip
    ensureHandoff(direction);

    if(direction === "forward"){
      // flip rightPage (odd) -> backside is rightPage+1 (even)
      // behind should show rightPage+2 on right, and left side becomes (optionally) previous stack; we’ll set spread underlay now:
      // Underlay during flip:
      // left shows current leftPage (if any) else empty
      // right shows nextRight = rightPage+2 (or empty if none)
      const nextLeft = rightPage + 1;         // backside
      const nextRight = (rightPage + 2 <= TOTAL_PAGES) ? (rightPage + 2) : null;

      // Set underlay pages (what you see behind the turning page)
      // Left underlay: keep current leftPage until flip completes (visually acceptable and stable)
      // Right underlay: nextRight (page3 when flipping page1)
      clearSlot(leftSlot);
      clearSlot(rightSlot);
      leftSlot.appendChild(leftPage ? makeStaticPage(leftPage) : makeEmpty());
      rightSlot.appendChild(nextRight ? makeStaticPage(nextRight) : makeEmpty());

      // Create leaf (front=rightPage, back=nextLeft)
      leafEl = makeLeaf("forward", rightPage, nextLeft);
      book.appendChild(leafEl);

    } else {
      // backward flip uses leftPage (even) -> backside is leftPage-1 (odd)
      // behind should show prevLeft = leftPage-2 on left (or empty) and current rightPage on right (or empty)
      const prevRight = leftPage - 1;                 // backside
      const prevLeft = (leftPage - 2 >= 1) ? (leftPage - 2) : null;

      clearSlot(leftSlot);
      clearSlot(rightSlot);
      leftSlot.appendChild(prevLeft ? makeStaticPage(prevLeft) : makeEmpty());
      rightSlot.appendChild(rightPage ? makeStaticPage(rightPage) : makeEmpty());

      leafEl = makeLeaf("backward", leftPage, prevRight);
      book.appendChild(leafEl);
    }
  }

  function setFlipProgress(p){
    rawProgress = Math.max(0, Math.min(1, p));
    currentProgress = smootherstep(rawProgress);
    if(!leafEl) return;

    // rotation: forward goes 0 -> -180, backward goes 0 -> +180
    const dir = leafEl.dataset.direction;
    const deg = (dir === "forward") ? (-180 * currentProgress) : (180 * currentProgress);
    leafEl.style.transform = `rotateY(${deg}deg)`;

    // shade opacity increases mid-flip
    const shade = leafEl.querySelector(".shade");
    if(shade){
      const mid = 1 - Math.abs(0.5 - currentProgress) * 2; // 0 at ends, 1 at mid

      // Base leaf shade
      const baseShade = 0.55 * mid;

      // Shadow handoff timing: last 25% of raw drag distance
      const t = Math.max(0, Math.min(1, (rawProgress - 0.75) / 0.25)); // 0 at 0.75, 1 at 1.0
      const fadeIn = t * t * (3 - 2 * t); // smoothstep

      // Soften leaf shade slightly near completion to prevent lighting swap jump
      const endFactor = 1 - 0.35 * fadeIn;
      shade.style.opacity = (baseShade * endFactor).toFixed(3);

      // Bridge overlay fades in near the end to match final static lighting
      if(handoffEl){
        handoffEl.style.opacity = (0.38 * fadeIn).toFixed(3);
      }

      // soft ambient spine shadow shift
      if(spine){
        const base = 0.35;
        const extra = 0.22 * mid;
        spine.style.opacity = (base + extra).toFixed(3);
      }
    }
  }

  function endFlip(commit){
    if(!leafEl) return;

    // animate to end or back
    const from = currentProgress;
    const to = commit ? 1 : 0;
    const start = performance.now();
    const dur = 240;

    function anim(t){
      const k = Math.min(1, (t - start) / dur);
      // easeInOut
      const e = k < 0.5 ? 2*k*k : 1 - Math.pow(-2*k + 2, 2)/2;
      const p = from + (to - from) * e;
      setFlipProgress(p);
      if(k < 1) requestAnimationFrame(anim);
      else finalize();
    }

    function finalize(){
      const dir = leafEl.dataset.direction;
      leafEl.remove();
      leafEl = null;

      // ease spine back and remove bridge overlay smoothly
      if(spine){
        spine.style.transition = "opacity 160ms ease-out";
        spine.style.opacity = "0.35";
        setTimeout(() => { if(spine) spine.style.transition = ""; }, 180);
      }
      removeHandoffSoon();

      if(commit){
        // micro haptic on supported devices
        if(navigator.vibrate) navigator.vibrate(8);
        // sine-tone flip sound
        playSineSequence(dir === "forward");
      }

      if(commit){
        if(dir === "forward"){
          // After forward flip of rightPage:
          // end spread: left = rightPage+1, right = rightPage+2 (or null)
          const newLeft = rightPage + 1;
          const newRight = (rightPage + 2 <= TOTAL_PAGES) ? (rightPage + 2) : null;
          leftPage = newLeft;
          rightPage = newRight;
        } else {
          // After backward flip of leftPage:
          // end spread: right = leftPage-1, left = leftPage-2 (or null)
          const newRight = leftPage - 1;
          const newLeft = (leftPage - 2 >= 1) ? (leftPage - 2) : null;

          // Special: when we reach the very beginning, show only page 1 on right
          leftPage = newLeft;
          rightPage = newRight;

          if(rightPage === 1){
            leftPage = null;
          }
        }
      }

      renderSpread();
    }

    requestAnimationFrame(anim);
  }

  // ---- INPUT HANDLING ----
  function getLocalX(clientX){
    const r = book.getBoundingClientRect();
    return clientX - r.left;
  }

  function shouldSuppressTap(e){
    // Only suppress touch taps (mouse double-click handled separately)
    if(e.pointerType !== "touch") return false;
    const now = performance.now();

    // If we are within an active suppression window, ignore
    if(now < suppressUntil) return true;

    // Detect double-tap: quick succession + small movement
    const dt = now - lastTapTime;
    const dx = e.clientX - lastTapX;
    const dy = e.clientY - lastTapY;
    const dist = Math.hypot(dx, dy);

    if(dt > 0 && dt < 280 && dist < 26){
      // suppress for a short window to avoid browser smart zoom / snapshot artifacts
      suppressUntil = now + 420;
      interactionLockUntil = now + 520;
      return true;
    }

    // record this tap as a candidate for the next one
    lastTapTime = now;
    lastTapX = e.clientX;
    lastTapY = e.clientY;
    return false;
  }

  function pointerDown(e){
    // Only primary pointer
    if(e.pointerType === "mouse" && e.button !== 0) return;

    // Global cooldown (prevents dblclick/smart-zoom causing frozen snapshots)
    const now = performance.now();
    if(now < interactionLockUntil){
      if(bookViewport) bookViewport.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    // If a flip is currently active, ignore new starts
    if(leafEl || isDragging){
      if(bookViewport) bookViewport.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    // Mouse double-click: ignore second click (e.detail >= 2)
    if(e.pointerType === "mouse" && e.detail >= 2){
      interactionLockUntil = now + 450;
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    // Suppress rapid double-taps that can trigger browser smart-zoom / image snapshot glitches
    if(shouldSuppressTap(e)){
      if(bookViewport) bookViewport.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    // Track pointers for pinch
    activePointers.set(e.pointerId, {x: e.clientX, y: e.clientY});

    // If a second pointer goes down, enter pinch mode and cancel any flip
    if(activePointers.size === 2){
      isPinching = true;
      // cancel in-progress flip cleanly
      if(leafEl){
        endFlip(false);
      }

      const pts = [...activePointers.values()];
      const dx = pts[0].x - pts[1].x;
      const dy = pts[0].y - pts[1].y;
      pinchStartDist = Math.hypot(dx, dy) || 1;
      pinchStartScale = zoomScale;
      pinchStartPanX = panX;
      pinchStartPanY = panY;
      pinchStartCenter = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };

      if(bookViewport) bookViewport.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    // If already pinching, ignore single-pointer flip logic
    if(isPinching){
      if(bookViewport) bookViewport.setPointerCapture(e.pointerId);
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    const r = book.getBoundingClientRect();
    const x = e.clientX - r.left;
    const isRightHalf = x > r.width/2;
    const isLeftHalf  = !isRightHalf;

    // Decide direction based on where user starts
    // If they start on right half and we can flip forward, begin forward
    // If they start on left half and we can flip backward, begin backward
    if(isRightHalf && canFlipForward()){
      dragDir = "forward";
    } else if(isLeftHalf && canFlipBackward()){
      dragDir = "backward";
    } else {
      dragDir = null;
      return;
    }

    isDragging = true;
    startX = x;
    currentProgress = 0;

    rawProgress = 0;
    lastRawP = 0;
    lastVel = 0;
    lastMoveT = performance.now();

    beginFlip(dragDir);
    setFlipProgress(0);

    if(bookViewport) bookViewport.setPointerCapture(e.pointerId);
    e.preventDefault();
    e.stopPropagation();
  }

  function pointerMove(e){
    if(activePointers.has(e.pointerId)){
      activePointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
    }

    if(isPinching && activePointers.size >= 2){
      const pts = [...activePointers.values()];
      const dx = pts[0].x - pts[1].x;
      const dy = pts[0].y - pts[1].y;
      const dist = Math.hypot(dx, dy) || 1;
      const center = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };

      const scale = clamp(pinchStartScale * (dist / pinchStartDist), ZOOM_MIN, ZOOM_MAX);

      // two-finger pan follows the pinch center movement
      panX = pinchStartPanX + (center.x - pinchStartCenter.x);
      panY = pinchStartPanY + (center.y - pinchStartCenter.y);

      // update baselines to allow smooth continuous 2-finger panning
      pinchStartPanX = panX;
      pinchStartPanY = panY;
      pinchStartCenter = center;
      pinchStartScale = zoomScale;
      pinchStartDist = dist;

      // Apply pinch scale + two-finger pan together
      zoomScale = scale;
      applyViewTransform();

      e.preventDefault();
      e.stopPropagation();
      return;
    }

    if(!isDragging || !dragDir || !leafEl) return;

    const r = book.getBoundingClientRect();
    const x = e.clientX - r.left;

    // progress is how far user drags across half-width
    // forward: drag from right towards left increases progress
    // backward: drag from left towards right increases progress
    const half = r.width / 2;
    let delta;

    if(dragDir === "forward"){
      // start on right half; moving left increases
      delta = (startX - x);
    } else {
      delta = (x - startX);
    }

    const p = delta / half;

    // velocity estimate in progress/ms
    const now = performance.now();
    const dt = Math.max(1, now - lastMoveT);
    const newRaw = Math.max(0, Math.min(1, p));
    lastVel = (newRaw - lastRawP) / dt;
    lastRawP = newRaw;
    lastMoveT = now;

    setFlipProgress(p);

    e.preventDefault();
    e.stopPropagation();
  }

  function pointerUp(e){
    // Remove pointer from tracking
    activePointers.delete(e.pointerId);

    // Exit pinch mode when fewer than 2 pointers remain
    if(isPinching && activePointers.size < 2){
      isPinching = false;
      // reset pinch baselines
      pinchStartDist = 0;
      e.preventDefault();
      e.stopPropagation();
      return;
    }

    if(!isDragging) return;
    isDragging = false;

    if(!leafEl){
      dragDir = null;
      return;
    }

    // Commit based on distance OR flick velocity
    // lastVel is progress/ms (positive means moving toward completing the flip)
    const distanceCommit = rawProgress > 0.5;
    const flickCommit = lastVel > 0.0025 && rawProgress > 0.18;
    const flickCancel = lastVel < -0.0025 && rawProgress < 0.82;

    const commit = flickCancel ? false : (distanceCommit || flickCommit);
    endFlip(commit);

    dragDir = null;
    e.preventDefault();
    e.stopPropagation();
  }

  // ---- PROGRAMMATIC NAVIGATION ----
  function isAnimating(){
    return !!leafEl;
  }

  function goForward(){
    if(isAnimating()) return;
    if(!canFlipForward()) return;
    dragDir = "forward";
    beginFlip("forward");
    setFlipProgress(0);
    // force commit animation
    rawProgress = 0;
    currentProgress = 0;
    endFlip(true);
  }

  function goBackward(){
    if(isAnimating()) return;
    if(!canFlipBackward()) return;
    dragDir = "backward";
    beginFlip("backward");
    setFlipProgress(0);
    rawProgress = 0;
    currentProgress = 0;
    endFlip(true);
  }

  function jumpToPage(n){
    const page = Math.max(1, Math.min(TOTAL_PAGES, Math.floor(n || 1)));
    if(page === 1){
      leftPage = null;
      rightPage = 1;
    } else if(page === TOTAL_PAGES){
      leftPage = TOTAL_PAGES;
      rightPage = null;
    } else if(page % 2 === 0){
      leftPage = page;
      rightPage = page + 1;
    } else {
      leftPage = page - 1;
      rightPage = page;
    }
    renderSpread();
  }

  function openJump(){
    if(!jumpOverlay) return;
    jumpOverlay.classList.add("open");
    jumpOverlay.setAttribute("aria-hidden", "false");
    if(jumpInput){
      jumpInput.value = "";
      setTimeout(() => jumpInput.focus(), 0);
    }
  }

  function closeJump(){
    if(!jumpOverlay) return;
    jumpOverlay.classList.remove("open");
    jumpOverlay.setAttribute("aria-hidden", "true");
    if(book) book.focus?.();
  }

  function confirmJump(){
    if(!jumpInput) return;
    const val = parseInt(jumpInput.value, 10);
    if(!Number.isFinite(val)) return;
    jumpToPage(val);
    closeJump();
  }

  // Jump overlay interactions
  if(jumpGo) jumpGo.addEventListener("click", confirmJump);
  if(jumpCancel) jumpCancel.addEventListener("click", closeJump);
  if(jumpOverlay) jumpOverlay.addEventListener("click", (e) => {
    if(e.target === jumpOverlay) closeJump();
  });
  if(jumpInput) jumpInput.addEventListener("keydown", (e) => {
    if(e.key === "Enter") confirmJump();
    if(e.key === "Escape") closeJump();
  });

  // Keyboard navigation
  window.addEventListener("keydown", (e) => {
    // don’t steal keys while jump overlay is open
    const jumpOpen = jumpOverlay && jumpOverlay.classList.contains("open");
    if(jumpOpen){
      if(e.key === "Escape") closeJump();
      return;
    }

    if(e.key === "ArrowRight" || e.key === " "){
      e.preventDefault();
      goForward();
    }

    if(e.key === "ArrowLeft"){
      e.preventDefault();
      goBackward();
    }

    if(e.key === "g" || e.key === "G"){
      e.preventDefault();
      openJump();
    }
  }, {passive:false});

  // ---- INIT ----
  // Ensure we start at page 1 (right)
  leftPage = null;
  rightPage = 1;

  // Set Jump UI limits for a fixed 25-slide (50-page) book
  if(jumpInput){
    jumpInput.max = String(TOTAL_PAGES);
    jumpInput.placeholder = `1–${TOTAL_PAGES}`;
  }

  renderSpread();
  preloadAroundCurrent();

  // Attach ALL gesture handlers only on the viewport (avoids duplicate bubbling handlers)
  if(bookViewport){
    bookViewport.addEventListener("pointerdown", pointerDown, {passive:false});
    bookViewport.addEventListener("pointermove", pointerMove, {passive:false});
    bookViewport.addEventListener("pointerup", pointerUp, {passive:false});
    bookViewport.addEventListener("pointercancel", pointerUp, {passive:false});

    // Prevent double-tap/double-click default behavior, and hard reset view (capture phase)
    bookViewport.addEventListener("dblclick", (e) => {
      const now = performance.now();
      interactionLockUntil = now + 500;
      e.preventDefault();
      e.stopPropagation();
      hardResetView("dblclick");
    }, {passive:false, capture:true});

    // iOS Safari: prevent gesture-based smart zoom (can cause frozen snapshot artifacts)
    bookViewport.addEventListener("gesturestart", (e) => { e.preventDefault(); }, {passive:false});
    bookViewport.addEventListener("gesturechange", (e) => { e.preventDefault(); }, {passive:false});
    bookViewport.addEventListener("gestureend", (e) => { e.preventDefault(); }, {passive:false});
  }

  // Backstop: prevent browser from interpreting rapid taps as zoom, and hard reset (capture phase)
  document.addEventListener("dblclick", (e) => {
    const now = performance.now();
    interactionLockUntil = now + 500;
    e.preventDefault();
    e.stopPropagation();
    hardResetView("document-dblclick");
  }, {passive:false, capture:true});

  // Desktop ctrl/cmd + wheel zoom
  if(bookViewport){
    bookViewport.addEventListener("wheel", (e) => {
      // Ctrl/Cmd + wheel is the most common trackpad pinch signal on desktop browsers
      const isZoomGesture = e.ctrlKey || e.metaKey;
      if(!isZoomGesture) return;
      e.preventDefault();

      const factor = Math.exp(-e.deltaY * 0.0016);
      const next = clamp(zoomScale * factor, ZOOM_MIN, ZOOM_MAX);
      zoomAt(next, e.clientX, e.clientY);
    }, {passive:false});
  }

  // Reset view with 0 key
  window.addEventListener("keydown", (e) => {
    if(e.key === "0"){
      zoomScale = 1;
      panX = 0;
      panY = 0;
      applyViewTransform();
    }
  });
})();
</script>
</body>
</html>
